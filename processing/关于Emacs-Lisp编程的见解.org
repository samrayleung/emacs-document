#+TITLE: 关于 Emacs-Lisp 编程的体会
#+URL: http://www.nongnu.org/emacs-tiny-tools/elisp-coding/index-body.html                                  
#+AUTHOR: Samray
#+CATEGORY: elisp-common
#+DATE: 
#+OPTIONS: ^:{}
--------------------------------------------------------------------------------------------------------------
* 1.0 Document id
  Copyright © 1995-2007 Jari Aalto

  License: This material may be distributed only subject to the terms and
  conditions set forth in GNU General Public License v2 or later; or, at your
  option, distributed under the terms of GNU Free Documentation License version
  1.2 or later (GNU FDL).

  本文档包含了关于 Unix Emacs Lisp 编程的信息。它发表了关于 Emacs lisp 编程的风格
  指南以及展示了关于 Emacs lisp编译器的信息。而本文档关于 Emacs-lisp 的代码剖析都
  是经过笔者亲自实践过的，而其中一部分代码的运行结果也会展示出来。
** 1.1 What this document is not
   本文档不会向你介绍 lisp, 在阅读本文档之前你需要了解基本的 lisp 知识，例如：函
   数，局部变量，全局变量以及在 lisp 中使用的各种列表。总而言之，本文不会为你提
   供解决特定问题的函数或者是具体的解决方案。不过还是会有一些学习案例的。
** 1.2 What is this document?
   本文包含着一些你可能觉得很方便的指南。这些指南可能是在 Emacs 用户组或者新闻列
   表上发布过的好的文章或者是你未曾品读过的好文章，无论如何，都希望你会喜爱它们。
   建议你在阅读本文之前，先去阅读一些那些优美的 lisp 编程指南。
   
   本文包含的是对编程的最佳实践的一些指导建议，但是它不是你一定要遵守的 "戒律
   ". 你可以择善而从，不喜则无视之。
   
   而 Elp (lisp profiling tool-lisp 分析工具)可能适用于那些很谨慎的读者，特别是
   它们需要指南来编写紧湊的循环，用时少的函数。不过通常在 Emacs 里面这些都是不需
   要进行优化的：因为你很少会遇上性能问题。不过你不应该盲目相信这些代码的运行结
   果，要持"批判的"态度去阅读它们。
   
   习惯的缩写：
   [jari] Jari Aalto
   [kai] Kai Grossjohann
   [vladimir] Vladimir Alexiev
* 2.0 The basic coding suggestions
** 2.1 Major rule1 - comment as much as possible
   当别人在阅读你的代码的时候，会为你添加的额外的解释而对你心存感激的。可能有一
   天，你的这些代码由另外一个程序员来维护. 所以你要谨记，当你不再为这些代码工作
   的时候，需要新的维护者来接管你的代码，而你的代码就代表着你自己，所以，还是尽
   量地让别人了解你吧。
** 2.2 Majro rule2 - maintenance comes first
   可维护性和可读性应该优先考虑，所以不要编写过于紧湊简短的代码。如果你的代码是"
   简洁"的，你的方法就很容易阅读。无论你如何紧缩你的代码，你的代码都不会跑得更快，
   但是却更有可能丧失可读性。有些人喜欢把他们的函数里面所有的空格删掉，这样他们
   的代码就可以"缩"成一行了，但是这些都并不是最佳实践。
   
   把相互关联的部分以组的形式组织起来，并在有重要事情发生的地方 (例如函数或者使
   条件判断)添加上破折号或者其他容易被注意到的符号
** 2.3 Majro rule3 - don't spare variables
   不要害怕使用很多变量，特别是在需要局部变量的函数里面。如果一个变量可以命名得
   合适，那么它本身就能解释代码的作用。使用 XEmacs 字节码编译器来检查一下你是否
   有定义过但未曾使用的变量，这样编译的结果就可以更加整洁 (需要注意：XEmacs 的字
   节码编译器可以比 Emacs 字节码编译器更好地捕捉编程错误)
   
   在大多数情况下，使用过多变量所导致的副作用都是可以忽略的。留意本文接下来的分
   析结果。
** 2.4 Major rule4 - document your functions and variables well
   为你的函数和变量写好文档。如果函数里面定义了全局变量，那么在文档中说明 (使用
   "References:" 标签). 每一个函数和变量都应该有 DOC-STRING (字符形式的文档), 因
   为当你调用 /describe-symbols/ 函数的时候，它会打印出符号 (SYMBOL) 和对应的文
   档 (DOC-STRING). 并且你也可以使用 /super-apropos/ 函数搜索文档字符。不要忘记
   在字符文档的第一行应该是完整的语句。
   
   如果你以这样的形式编写代码，难道你不会感到沮丧么？
   #+BEGIN_SRC emacs-lisp
   (defconst foo-list-storage nil)  
   #+END_SRC
   
   现在你必须通读代码才能了解变量在哪里使用以及如何去使用。最初的 Emacs 建议你在
   自定义的包的变量添加文档，就像上面的语句。但是这条建议历史已经很悠久了，回顾
   还是 Emacs 18.xx 的那些日子，文档字符串的内存空间是有限的。但是在新版的
   Emacs, 已经拥有可以减少字符文档内存消耗的动态字节码编译选项了。所以已经不需要
   通过减少字符串文档来 "手工优化"了
** 2.5 Major rule5 - don't use tricks
   考虑一下这样的情形，当你在开发的时候，有新的开发者加入，但是他/她是完全不了解
   Lisp 的。尽量编写清晰的代码. 不要使用奇巧淫技，因为这些技巧可能会对阅读你代码
   的读者不友好。在你编写那些看起来挺复杂的代码的时候，你同时需要编写好的文档来
   解释你的代码。
** 2.6 Major rule6 - use byte compiler to check leaks
   使用 /emacs -q/ 命令来启动新的 Emacs 实例，然后通过运行 /M-x
   byte-compile-file/ 来编译 XXX.el 文件以检查你的代码是否存在变量泄漏。
** 2.7 Use the error function
   如果你不能继续执行代码时，使用 /error/ 命令，或者是当其他的程序依赖于你的代码，
   最好是这些代码也无法继续执行。不要去处理不要的错误条件－在 Emacs Lisp 它通常
   是不会工作的，就好像你熟悉的 Java 或者是 C++里面的 throw 语句。
** 2.8 Make function as general as possible
   但不是普遍得可以吃苹果或者汽车 (译者注：译者也很迷，But not so general that
   it can eat apples and cars). 刚刚好就差不多了，函数无需太过长，如果还是很长得
   话，可以使用 /cond/ 语句。有时候可能你没办法继续细分任务，或者是继续划分函数
   不合情理，遇到这些情况你就要自己进行判断。
   
   其次，太长的函数会让你有这不是好的代码的感觉。通常都会有可以重用的代码，这些
   代码就可以独立出来，但是，也可能保留在原来的函数。只要你可以说服自己: 这些长
   的函数就是你所需要的。
* 3.0 Coding style issues
** 3.1 Function's variable definitions
   不整洁的代码：
   #+BEGIN_SRC emacs-lisp
   defun xx (arg1 arg2 &optional arg3 )
         (let ((foo 1) (bar "xx") baz-flag point))
          ...    
   #+END_SRC
   或许写成这样会更好：
   #+BEGIN_SRC emacs-lisp
   (defun xx (arg1 arg2 &optional arg3 )
         (let* ((foo         1)                ;temporary counter
                (bar         "xx")             ;displayed value
                baz-flag
                point)
         ...    
   #+END_SRC
   小提示：如果那些让 /let/ 语句中的变量排列得更加美观，你可以使用一些扩展的包，
   例如 *tinytab*, 这是一个 tab 的 minor mode.
   + 把需要初始化的变量放到最前面，然后是不需要初始化的变量。上面的例子 /foo/ 和
     /bar/ 就定义在 /baz-flag/ 和 /point/ 之前
   + 把每一个变量放到单独的一行，并且在需要的时候，添加关于用法的注释。
   + 命名变量的时候尽量使用描述性的名字。这样有助阅读，例如选择 "buffer" 而不是 "b" 或者 "buf"
   + 长的名字大多数情况下都是更好的选择。
** 3.2 Let with initialised empty values
   让我们来看一下示例代码：
   #+BEGIN_SRC emacs-lisp
     (let* ((foo '())    ;; A list
   	 (bar nil)    ;; A truth value
   	 test)        ;; A scratch variable.  
   #+END_SRC
   初始时将 /foo/,/bar/,/test/ 置为 /nil/ 是行之有效的。不要让额外的因素迷惑了你。
   程序员的意图是很清晰地： /foo/ 变量是一个 list,并且它用 /()/ 来初始化表面它接
   收的参数是 list 中的元素等等。但是示例代码还可以更加地简洁。在开发者的视线中
   出现越多的符号，人类的目光就更不容易聚焦到重要的内容。我们可以尝试以下下面的代码：
   #+BEGIN_SRC emacs-lisp
         (let* (foo-list     ;; A list
             bar-flag     ;; A truth value
             test)        ;; A scratch variable.   
   #+END_SRC
   在上面的代码，变量名就阐述了它们的用处，此外，省略掉的符号明显改善了代码结构。
   你自己知道，这些变量默认值就是 /nil/,所以就没有必要给变量赋值一个空列表了。绝
   大部分情况下，少即是多 (less is more). 此外，在函数体里面使用这些变量的时候，
   变量代表的意义总是非常清晰的，因为它们的名字就阐明了它们的用处。
** There are alternatives to `progn`
   /progn/ 可以让代码快速地向右缩进，并且让你以紧湊的形式编写代码。下面列出来的
   示例代码都具有同样的效果。
   #+BEGIN_SRC emacs-lisp
         (if variable                    ;test here
          (progn
             ...it was non-nil , do something))   
   #+END_SRC
   有时候 /cond/ 像 /progn/ 那样被使用。它具有隐式的 /progn/ 风格：
   #+BEGIN_SRC emacs-lisp
     (cond
       (variable                      ;test here
        ...code..
        ...code..))    
   #+END_SRC
   此外，还有 /and/ 关键字，但是它需要你所有将要执行的语句都返回一个 非空值。所
   以不是每次都可以像 /progn/ 那样被使用：
   #+BEGIN_SRC emacs-lisp
      (and variable
           ..code..
           ..code..) 
   #+END_SRC
   在 Common lisp 的库， /cl.el/ 提供了更简洁的使用方法。这也更加优雅，个人更倾
   向于这种表达方式：
   #+BEGIN_SRC emacs-lisp
         (eval-when-compile (require 'cl))

      (when variable
        ...code..
        ...code..)    
   #+END_SRC
   [vladimir 语：] 还有很多糟糕的用法。我可以想到的最糟糕的用法就是对一个内联函
   数使用映射 (mapcar)：
   #+BEGIN_SRC emacs-lisp
      (mapcar (function (lambda (e)
                          (do stuff)))
            '(1 2 3))    
   #+END_SRC
   上面的代码预留太少的位置来编写逻辑代码了; 特别是当包含另外一个隐射函数的时候。
   下面的代码看起来就好多了：
   #+BEGIN_SRC emacs-lisp
         (mapcar
       (function
        (lambda (e)
          (do stuff)))
       '(1 2 3))    
   #+END_SRC
